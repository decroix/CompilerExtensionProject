package amyc
package codegen

import analyzer._
import ast.{Identifier, SymbolicTreeModule}
import ast.SymbolicTreeModule.{And => AmyAnd, Call => AmyCall, Div => AmyDiv, Or => AmyOr, _}
import utils.{Context, Pipeline}
import amyc.wasm.Instructions._
import wasm._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }



    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {


      def isClean(expr: Expr): Boolean = {
        expr match {

          // Variables
          case Variable(n) =>
            true

          // Literals
          case IntLiteral(value) =>
            true
          case BooleanLiteral(value) =>
            true
          case StringLiteral(value) =>
            true
          case UnitLiteral() =>
            true

          // Binary operators
          case Plus(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case Minus(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case Times(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case AmyDiv(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case Mod(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case LessThan(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case LessEquals(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case AmyAnd(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case AmyOr(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case Equals(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)
          case Concat(lhs, rhs) =>
            isClean(lhs) && isClean(rhs)

          // Unary operators
          case Not(e) =>
            isClean(e)
          case Neg(e) =>
            isClean(e)

          // Function/ type constructor call
          case AmyCall(qname, args) =>
            val const = table.getConstructor(qname)
            if(const.isDefined) {
              args.foldLeft(true)((prev, curr) => prev && isClean(curr))
            }
            else {
              val func = table.getFunction(qname).get
              if(func.owner == "Std") false //Hard code js functions such as read, print functions
              args.foldLeft(true)((prev, curr) => prev && isClean(curr))
            }

          // The ; operator
          case Sequence(e1, e2) =>
            isClean(e1) && isClean(e2)

          // Local variable definition
          case Let(_, value, body) =>
            isClean(value) && isClean(body)

          // If-then-else
          case Ite(cond, thenn, elze) =>
            isClean(cond) && isClean(thenn) && isClean(elze)

          // Pattern matching
          case Match(scrut, cases) =>
            isClean(scrut) && cases.foldLeft(true)((prev, curr) => prev && isClean(curr.expr))

          // Represents a computational error; prints its message, then exits
          // Obvious case where a behavior need to be executed even if the variable is not used
          case Error(_) =>
            false
        }
      }

      // Check if the given variable as an Identifier is used in the test expression
      def isUsed(expr: Expr, name: Identifier): Boolean ={
        expr match {
          // Variables
          // The only important case where we need to check if the variable is used
          case Variable(n) =>
            n == name

          // Literals
          case IntLiteral(value) =>
            false
          case BooleanLiteral(value) =>
            false
          case StringLiteral(value) =>
            false
          case UnitLiteral() =>
            false

          // Binary operators
          case Plus(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case Minus(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case Times(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case AmyDiv(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case Mod(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case LessThan(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case LessEquals(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case AmyAnd(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case AmyOr(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case Equals(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)
          case Concat(lhs, rhs) =>
            isUsed(lhs, name) || isUsed(rhs, name)

          // Unary operators
          case Not(e) =>
            isUsed(e, name)
          case Neg(e) =>
            isUsed(e, name)

          // Function/ type constructor call
          case AmyCall(_, args) =>
            args.foldLeft(false)((prev, curr) => prev ||isUsed(curr, name))

          // The ; operator
          case Sequence(e1, e2) =>
            isUsed(e1, name) || isUsed(e2, name)

          // Local variable definition
          case Let(_, value, body) =>
            isUsed(value, name) || isUsed(body, name)

          // If-then-else
          case Ite(cond, thenn, elze) =>
            isUsed(cond, name) || isUsed(thenn, name) ||isUsed(elze, name)

          // Pattern matching
          case Match(scrut, cases) =>
            isUsed(scrut, name) || cases.foldLeft(false)((prev, curr) => prev || isUsed(curr.expr, name))

          // Represents a computational error; prints its message, then exits
          case Error(msg) =>
            isUsed(msg, name)
        }
      }

      //For pattern match later
      def getCondAndLocals(index : Int, pattern : SymbolicTreeModule.Pattern): (Code, Map[Identifier, Int]) = {
        pattern match {
          case WildcardPattern() =>
            (Const(1), locals) //Set to true
          case IdPattern(name) =>
            val idIndex = lh.getFreshLocal()
            (GetLocal(index) <:> SetLocal(idIndex) <:> Const(1), locals + (name -> idIndex)) // Add a new local for the id and set to true
          case LiteralPattern(lit) =>
            (GetLocal(index) <:> cgExpr(lit) <:> Eq, locals) //Check if the literal matches with the scrut
          case CaseClassPattern(constr, args) =>
            val construtor = table.getConstructor(constr).get
            val andCode = args.zipWithIndex.map { case (constrPat, i) =>           //Generate code to check if arguments matches
              val constrArgIndex = lh.getFreshLocal()
              val (cond, newLocals) = getCondAndLocals(constrArgIndex, constrPat)  //Get condition for arg to match and new locals
              val andCond = GetLocal(index) <:> //Add condition to stack
                adtField(i) <:>
                Load <:>
                SetLocal(constrArgIndex) <:>
                cond
              (andCond, newLocals)
            }
            val finalCond =                  //Make a big And with all the arguments conditions
              GetLocal(index) <:>
              Load <:>
              Const(construtor.index) <:>
              Eq <:>
              andCode.map(_._1) <:>
              List.fill(args.size)(And)

            val finalLocals = andCode.map(_._2).foldLeft(locals)((curr, newlocals) => curr ++ newlocals)  //Return big condition with locals

            (finalCond, finalLocals)
        }
      }


      expr match {
        // Variables
        case Variable(name) =>
          GetLocal(locals(name))

        // Literals
        case IntLiteral(value) =>
          Const(value)
        case BooleanLiteral(value) =>
          if(value){
            Const(1)
          }else{
            Const(0)
          }
        case StringLiteral(value) =>
          mkString(value)
        case UnitLiteral() =>
          Const(0)

        // Binary operators
        case Plus(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case AmyAnd(lhs, rhs) =>
          //Compute only the first instruction and then compute the second one if true (to compute only the necessary)
          cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
        case AmyOr(lhs, rhs) =>
          //Compute only the first instruction and if false compute the second one (to compute only the necessary)
          cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End
        case Equals(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Concat(lhs, rhs) =>
          cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)

        // Unary operators
        case Not(e) =>
          cgExpr(e) <:> Eqz
        case Neg(e) =>
          //Multiply by -1 to neg
          cgExpr(e) <:> Const(-1) <:> Mul

        // Function/ type constructor call
        case AmyCall(qname, args) =>
          table.getConstructor(qname) match {
            case Some(value) =>
              val pointer = lh.getFreshLocal()

              GetGlobal(memoryBoundary) <:>
              SetLocal(pointer) <:>
              GetGlobal(memoryBoundary) <:>
              Const(value.index) <:> //Set value for the constructor index in first memory slot
              Store <:>
              GetGlobal(memoryBoundary) <:>
              Const(4 * (args.size + 1)) <:> //Prepare the memory for the args
              Add <:>
              SetGlobal(memoryBoundary) <:>
              args.zipWithIndex.map { case (arg, i) => // Store every args in memory slots
                GetGlobal(pointer) <:>
                adtField(i) <:> //Point to desired index
                cgExpr(arg) <:>
                Store           //Store new argument
              } <:>
              GetLocal(pointer)

            case None =>
              val func = table.getFunction(qname).get
              //Call function
              args.map(cgExpr) <:> Call(fullName(func.owner, qname))
          }

        // The ; operator
        case Sequence(e1, e2) =>
          cgExpr(e1) <:> Drop <:> cgExpr(e2)

        // Local variable definition
        case Let(df, value, body) =>
          if(isUsed(body, df.name) || !isClean(value)){
            // Case where the variable definition is not dead code
            val id = lh.getFreshLocal()
            cgExpr(value) <:> SetLocal(id) <:> cgExpr(body)(locals + (df.name -> id), lh)
          }
          else {
            // Case where the variable definition is dead code, we simply generate code for the body
            cgExpr(body)
          }


        // If-then-else
        case Ite(cond, thenn, elze) =>
          cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> cgExpr(elze)

        // Pattern matching
        case Match(scrut, cases) =>
          val i = lh.getFreshLocal()
          val ifImbrication = cases.map{ case c =>
              val (cond, newLocals) = getCondAndLocals(i, c.pat)
              cond <:> If_i32 <:> cgExpr(c.expr)(newLocals, lh) <:> Else
          }

          cgExpr(scrut) <:>
          SetLocal(i) <:>
          ifImbrication <:>
          mkString("Error : not match found with the given cases") <:> // Throw error or default case
          Call("Std_printString") <:>
          Unreachable <:>
          List.fill(ifImbrication.size)(End) // Close all if opened

        // Represents a computational error; prints its message, then exits
        case Error(msg) =>
          cgExpr(msg) <:> Call("Std_printString") <:> Unreachable


      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
